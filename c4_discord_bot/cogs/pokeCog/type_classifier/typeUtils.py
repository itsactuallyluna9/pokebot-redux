from nltk.tokenize.sonority_sequencing import SyllableTokenizer
from enum import Enum

#all characters legally generated by base model
legal_chars = ['\n', ' ', '-', '.', '2', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']

#functions to encode and decode list[char]
char_to_int = dict((c, i) for i, c in enumerate(legal_chars))
int_to_char = dict((i, c) for c, i in char_to_int.items())

tokenizer = SyllableTokenizer()

def tokenizeText(text):
    # take input string, return list[int] of each character from the string tokenized
    try: 
        text = text.lower()
    except AttributeError:
        return [0] #handle NaN
    chars = [char_to_int[char] for char in list(text) if char in legal_chars]
    return chars

class Type(Enum):
    FIRE = 0
    WATER = 1
    GRASS = 2
    ELECTRIC = 3
    ICE = 4
    FIGHTING = 5
    POISON = 6
    GROUND = 7
    FLYING = 8
    PSYCHIC = 9
    BUG = 10
    ROCK = 11
    GHOST = 12
    DARK = 13
    DRAGON = 14
    STEEL = 15
    FAIRY = 16
    NORMAL = 17
    NAN = 18

def encodeType(type_str):
    # takes str containing a valid type / nan (case-insensitive) and returns the int representation (between 0 and 18)
    try: 
        type_str = type_str.lower()
    except AttributeError:
        return Type.NAN.value #handle NaN
    
    try:
        type_enum = Type[type_str.upper()]
    except KeyError:
        raise ValueError(f'Invalid type entered: {type_str}')
    
    return type_enum.value

def decodeType(type_int):
    # takes int representing a valid type / nan (between 0 and 18) and returns the str equivalent
    try:
        type_enum = Type(type_int)
    except ValueError:
        raise ValueError(f'Invalid type entered: {type_int}')
    
    return type_enum.name.lower()

def encodeName(name):
    
    name = tokenizeText(name)
    
    while len(name) < 12:
        name.append(int(0)) 
    
    return name
